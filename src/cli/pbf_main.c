/* powerbf - a superb brainfuck interpreter
 * copyright (C) iLiquid, 2019 */

#include <stdio.h>
#include <unistd.h>

#include <pbf_args.h>
#include <pbf_chunk.h>
#include <pbf_compiler.h>
#include <pbf_panic.h>
#include <pbf_vm.h>

/* options */

/* #define BENCHMARK */
/* â†‘ uncomment to enable benchmarks */

/* optional includes */
#ifdef BENCHMARK
# include "cycle.h"
#endif

/* file instream implementation */

size_t ifs_read_impl(pbf_instream_t *fs, char *dest, size_t size) {
  return fread((void *)dest, sizeof(char), size, (FILE *)fs->userdata);
}

void ifs_init(pbf_instream_t *fs, FILE *file) {
  fs->read_impl = ifs_read_impl;
  fs->userdata = (void *)file;
}

void ifs_open(pbf_instream_t *fs, char *filename) {
  if (access(filename, R_OK) == -1) {
    pbf_panicf("file '%s' doesn't exist\n", filename);
  }
  ifs_init(fs, fopen(filename, "r"));
}

void ifs_close(pbf_instream_t *fs) {
  fclose((FILE *)fs->userdata);
}

/* CLI options */

typedef struct argp_userdata {
  char *filename;
  bool disassemble;
  bool optimize;
} argp_userdata_t;

void arg_help(pbf_argp_t *p, char *val) {
  fprintf(stderr,
    "powerbf - a superb brainfuck interpreter\n"
    "copyright (C) iLiquid, 2019\n"
    "\n"
    "USAGE\n"
    "  %s [options] <filename>\n"
    "\n"
    "OPTIONS\n"
    "  -h                 show help\n"
    "  -a                 disassemble generated bytecode (doesn't run code!)\n"
    "  -o <on|off>        toggle optimizations (default: on)\n"
    "                     disabling makes compilation faster but runtime slow\n"
    "\n",
    p->executable);
  exit(0);

  (void)p;
  (void)val;
}

#define simple_arg(name, field, value) \
  void arg_##name(pbf_argp_t *p, char *val) { \
    argp_userdata_t *data = (argp_userdata_t *)p->userdata; \
    data->field = value; \
    \
    (void)val; \
  }
#define bool_arg(name, field) \
  void arg_##name(pbf_argp_t *p, char *val) { \
    argp_userdata_t *data = (argp_userdata_t *)p->userdata; \
    if (strcmp(val, "on") == 0) { data->field = true; } \
    else if (strcmp(val, "off") == 0) { data->field = false; } \
    else { pbf_panicf("invalid boolean value: '%s'\n", val); } \
  }

simple_arg(disassemble, disassemble, true)
bool_arg(optimize, optimize)

void arg_file(pbf_argp_t *p, char *val) {
  argp_userdata_t *data = (argp_userdata_t *)p->userdata;
  if (data->filename == NULL) {
    data->filename = val;
  } else {
    pbf_panic("too many arguments (filename specified twice)\n");
  }
}

#undef bool_arg
#undef simple_arg

/* VM IO implementation */

void vm_put(pbf_vm_t *vm, char c) {
  putchar(c);

  (void)vm;
}

char vm_get(pbf_vm_t *vm) {
  (void)vm;
  return getchar();
}

/* main() */

int main(int argc, char *argv[]) {
  /* read command line arguments */
  pbf_argp_t argp;
  argp_userdata_t argp_data = {
    .filename = NULL,
    .disassemble = false,
    .optimize = true
  };

  pbf_argp_init(&argp);
  argp.userdata = (void *)&argp_data;

  pbf_argp_on_flag(&argp, true, 'h', arg_help);
  pbf_argp_on_flag(&argp, true, 'a', arg_disassemble);
  pbf_argp_on_flag(&argp, false, 'o', arg_optimize);
  pbf_argp_on_argument(&argp, arg_file);

  pbf_argp_parse(&argp, argc, argv);

  /* create file stream */
  pbf_instream_t instream;
  bool read_from_stdin = argp_data.filename == NULL;

  if (read_from_stdin) {
    ifs_init(&instream, stdin);
  } else {
    ifs_open(&instream, argp_data.filename);
  }

  /* compile */
  #ifdef BENCHMARK
  ticks total_start = getticks();
  #endif

  pbf_chunk_t bytecode;
  pbf_chunk_init(&bytecode);

  #ifdef BENCHMARK
  ticks compile_start = getticks();
  #endif

  pbf_compile(&bytecode, &instream);
  if (argp_data.optimize) {
    pbf_optimize(&bytecode);
  }

  #ifdef BENCHMARK
  ticks compile_end = getticks();
  double compile_time = elapsed(compile_end, compile_start);
  fprintf(stderr, "compile: %f\n", compile_time);
  #endif

  /* -a switch (disassemble bytecode) */
  if (argp_data.disassemble) {
    pbf_chunk_disassemble(&bytecode);
    goto cleanup;
  }

  /* run */
  pbf_vm_t vm;
  pbf_vm_init(&vm);
  vm.put_impl = vm_put;
  vm.get_impl = vm_get;

  #ifdef BENCHMARK
  ticks run_start = getticks();
  #endif

  pbf_vm_run(&vm, &bytecode);

  #ifdef BENCHMARK
  ticks run_end = getticks();
  double run_time = elapsed(run_end, run_start);
  double total_time = elapsed(run_end, total_start);
  fprintf(stderr, "run: %f\n", run_time);
  fprintf(stderr, "total: %f\n", total_time);
  #endif

  /* clean up */
cleanup:
  pbf_vm_deinit(&vm);
  pbf_chunk_deinit(&bytecode);
  if (!read_from_stdin) {
    ifs_close(&instream);
  }
}
